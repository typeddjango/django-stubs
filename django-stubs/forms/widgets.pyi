from datetime import time
from decimal import Decimal
from itertools import chain
from typing import Any, Callable, Dict, Iterator, List, Optional, Set, Tuple, Type, Union, Iterable

from django.contrib.admin.options import BaseModelAdmin
from django.core.files.base import File
from django.core.files.uploadedfile import SimpleUploadedFile
from django.db.models.fields.files import FieldFile
from django.forms.forms import BaseForm
from django.forms.renderers import EngineMixin
from django.utils.datastructures import MultiValueDict
from django.utils.safestring import SafeText

class MediaOrderConflictWarning(RuntimeWarning): ...

class Media:
    _js: str
    def __init__(
        self,
        media: Optional[type] = ...,
        css: Optional[Dict[str, Iterable[str]]] = ...,
        js: Optional[Iterable[str]] = ...,
    ) -> None: ...
    def render(self) -> str: ...
    def render_js(self) -> List[str]: ...
    def render_css(self) -> chain: ...
    def absolute_path(self, path: str) -> str: ...
    def __getitem__(self, name: str) -> Media: ...
    @staticmethod
    def merge(list_1: Iterable[Any], list_2: Iterable[Any]) -> Iterable[Any]: ...
    def __add__(self, other: Media) -> Media: ...

class MediaDefiningClass(type):
    def __new__(
        mcs: Type[MediaDefiningClass], name: str, bases: Tuple, attrs: Any
    ) -> Type[Union[BaseModelAdmin, BaseForm, Widget]]: ...

class Widget:
    needs_multipart_form: bool = ...
    is_localized: bool = ...
    is_required: bool = ...
    supports_microseconds: bool = ...
    attrs: Dict[str, Any] = ...
    def __init__(self, attrs: Optional[Dict[str, Any]] = ...) -> None: ...
    @property
    def is_hidden(self) -> bool: ...
    def subwidgets(
        self, name: str, value: Optional[List[str]], attrs: Dict[str, bool] = ...
    ) -> Iterator[Dict[str, Any]]: ...
    def format_value(self, value: Any) -> Optional[str]: ...
    def get_context(self, name: str, value: Any, attrs: Optional[Dict[str, Union[bool, str]]]) -> Dict[str, Any]: ...
    def render(
        self,
        name: str,
        value: Any,
        attrs: Optional[Dict[str, Union[bool, str]]] = ...,
        renderer: Optional[EngineMixin] = ...,
    ) -> SafeText: ...
    def build_attrs(
        self, base_attrs: Dict[str, Union[float, str]], extra_attrs: Optional[Dict[str, Union[bool, str]]] = ...
    ) -> Dict[str, Union[Decimal, float, str]]: ...
    def value_from_datadict(
        self, data: dict, files: Union[Dict[str, SimpleUploadedFile], MultiValueDict], name: str
    ) -> Any: ...
    def value_omitted_from_data(
        self, data: Dict[str, Any], files: Union[Dict[str, SimpleUploadedFile], MultiValueDict], name: str
    ) -> bool: ...
    def id_for_label(self, id_: str) -> str: ...
    def use_required_attribute(self, initial: Any) -> bool: ...

class Input(Widget):
    input_type: str = ...
    template_name: str = ...

class TextInput(Input): ...
class NumberInput(Input): ...
class EmailInput(Input): ...
class URLInput(Input): ...

class PasswordInput(Input):
    render_value: bool = ...

class HiddenInput(Input):
    choices: Iterable[Tuple[str, str]]

class MultipleHiddenInput(HiddenInput): ...

class FileInput(Input):
    needs_multipart_form: bool = ...

class ClearableFileInput(FileInput):
    clear_checkbox_label: Any = ...
    initial_text: Any = ...
    input_text: Any = ...
    def clear_checkbox_name(self, name: str) -> str: ...
    def clear_checkbox_id(self, name: str) -> str: ...
    def is_initial(self, value: Optional[Union[File, str]]) -> bool: ...
    def use_required_attribute(self, initial: Optional[Union[FieldFile, str]]) -> bool: ...

class Textarea(Widget):
    template_name: str = ...

class DateTimeBaseInput(TextInput):
    format_key: str = ...
    supports_microseconds: bool = ...
    format: Optional[str] = ...

class DateInput(DateTimeBaseInput): ...
class DateTimeInput(DateTimeBaseInput): ...
class TimeInput(DateTimeBaseInput): ...

class CheckboxInput(Input):
    check_test: Callable = ...
    def __init__(self, attrs: Optional[Dict[str, str]] = ..., check_test: Optional[Callable] = ...) -> None: ...

class ChoiceWidget(Widget):
    allow_multiple_selected: bool = ...
    input_type: Optional[str] = ...
    template_name: Optional[str] = ...
    option_template_name: Any = ...
    add_id_index: bool = ...
    checked_attribute: Any = ...
    option_inherits_attrs: bool = ...
    choices: List[List[Union[int, str]]] = ...
    def __init__(
        self,
        attrs: Optional[Dict[str, Union[bool, str]]] = ...,
        choices: Union[
            Iterator[Any], List[List[Union[int, str]]], List[Tuple[Union[time, int], int]], List[int], Tuple
        ] = ...,
    ) -> None: ...
    def options(self, name: str, value: List[str], attrs: Dict[str, Union[bool, str]] = ...) -> None: ...
    def optgroups(
        self, name: str, value: List[str], attrs: Optional[Dict[str, Union[bool, str]]] = ...
    ) -> List[Tuple[Optional[str], List[Dict[str, Union[Dict[str, Union[bool, str]], time, int, str]]], int]]: ...
    def create_option(
        self,
        name: str,
        value: Union[time, int, str],
        label: Union[int, str],
        selected: Union[Set[str], bool],
        index: int,
        subindex: Optional[int] = ...,
        attrs: Optional[Dict[str, Union[bool, str]]] = ...,
    ) -> Dict[str, Union[Dict[str, Union[bool, str]], Dict[str, bool], Set[str], time, int, str]]: ...
    def id_for_label(self, id_: str, index: str = ...) -> str: ...

class Select(ChoiceWidget):
    option_template_name: str = ...
    add_id_index: bool = ...
    checked_attribute: Any = ...
    option_inherits_attrs: bool = ...
    def use_required_attribute(self, initial: Any) -> bool: ...

class NullBooleanSelect(Select): ...

class SelectMultiple(Select):
    allow_multiple_selected: bool = ...

class RadioSelect(ChoiceWidget):
    can_add_related: bool
    option_template_name: str = ...

class CheckboxSelectMultiple(ChoiceWidget):
    allow_multiple_selected: bool = ...
    option_template_name: str = ...
    def use_required_attribute(self, initial: Optional[List[str]]) -> bool: ...
    def id_for_label(self, id_: str, index: Optional[str] = ...) -> str: ...

class MultiWidget(Widget):
    template_name: str = ...
    widgets: List[Widget] = ...
    def __init__(
        self,
        widgets: Union[List[Type[DateTimeBaseInput]], Tuple[Union[Type[TextInput], Input]]],
        attrs: Optional[Dict[str, str]] = ...,
    ) -> None: ...
    @property
    def is_hidden(self) -> bool: ...
    def decompress(self, value: Any) -> Optional[Any]: ...
    media: Any = ...

class SplitDateTimeWidget(MultiWidget):
    supports_microseconds: bool = ...
    def __init__(
        self,
        attrs: Optional[Dict[str, str]] = ...,
        date_format: Optional[str] = ...,
        time_format: Optional[str] = ...,
        date_attrs: Optional[Dict[str, str]] = ...,
        time_attrs: Optional[Dict[str, str]] = ...,
    ) -> None: ...

class SplitHiddenDateTimeWidget(SplitDateTimeWidget):
    def __init__(
        self,
        attrs: Optional[Dict[str, str]] = ...,
        date_format: None = ...,
        time_format: None = ...,
        date_attrs: Optional[Dict[str, str]] = ...,
        time_attrs: Optional[Dict[str, str]] = ...,
    ) -> None: ...

class SelectDateWidget(Widget):
    none_value: Any = ...
    month_field: str = ...
    day_field: str = ...
    year_field: str = ...
    template_name: str = ...
    input_type: str = ...
    select_widget: Any = ...
    date_re: Any = ...
    years: Any = ...
    months: Any = ...
    year_none_value: Any = ...
    month_none_value: Any = ...
    day_none_value: Any = ...
    def __init__(
        self,
        attrs: None = ...,
        years: Optional[Union[Tuple[Union[int, str]], range]] = ...,
        months: None = ...,
        empty_label: Optional[Union[Tuple[str, str], str]] = ...,
    ) -> None: ...
