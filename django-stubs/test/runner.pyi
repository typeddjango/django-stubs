import logging
from argparse import ArgumentParser
from contextlib import contextmanager
from io import StringIO
from typing import Any, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, Union
from unittest import TestCase, TestLoader, TestSuite, TextTestResult, TextTestRunner

from django.db.backends.base.base import BaseDatabaseWrapper
from django.test.testcases import SimpleTestCase, TestCase
from django.test.utils import TimeKeeperProtocol
from django.utils.datastructures import OrderedSet
from typing_extensions import Literal

class DebugSQLTextTestResult(TextTestResult):
    buffer: bool
    descriptions: bool
    dots: bool
    expectedFailures: List[Any]
    failfast: bool
    shouldStop: bool
    showAll: bool
    skipped: List[Any]
    tb_locals: bool
    testsRun: int
    unexpectedSuccesses: List[Any]
    logger: logging.Logger = ...
    # typeshed thinks it's TextIO, but unittest wraps it with _WritelnDecorator
    # adding `writeln` method
    # See https://github.com/python/cpython/blob/main/Lib/unittest/runner.py
    stream: Any
    def __init__(self, stream: Any, descriptions: bool, verbosity: int) -> None: ...
    debug_sql_stream: StringIO = ...
    handler: logging.StreamHandler = ...
    def startTest(self, test: TestCase) -> None: ...
    def stopTest(self, test: TestCase) -> None: ...
    def addError(self, test: Any, err: Any) -> None: ...
    def addFailure(self, test: Any, err: Any) -> None: ...

class PDBDebugResult(TextTestResult): ...

class RemoteTestResult:
    events: List[Any] = ...
    failfast: bool = ...
    shouldStop: bool = ...
    testsRun: int = ...
    def __init__(self) -> None: ...
    @property
    def test_index(self) -> int: ...
    def check_picklable(self, test: Any, err: Any) -> None: ...
    def _confirm_picklable(self, obj: Any) -> None: ...
    def check_subtest_picklable(self, test: Any, subtest: Any) -> None: ...
    def stop_if_failfast(self) -> None: ...
    def stop(self) -> None: ...
    def startTestRun(self) -> None: ...
    def stopTestRun(self) -> None: ...
    def startTest(self, test: Any) -> None: ...
    def stopTest(self, test: Any) -> None: ...
    def addError(self, test: Any, err: Any) -> None: ...
    def addFailure(self, test: Any, err: Any) -> None: ...
    def addSubTest(self, test: Any, subtest: Any, err: Any) -> None: ...
    def addSuccess(self, test: Any) -> None: ...
    def addSkip(self, test: Any, reason: Any) -> None: ...
    def addExpectedFailure(self, test: Any, err: Any) -> None: ...
    def addUnexpectedSuccess(self, test: Any) -> None: ...

class RemoteTestRunner:
    resultclass: Any = ...
    failfast: bool = ...
    buffer: bool = ...
    def __init__(self, failfast: bool = ..., resultclass: Optional[Any] = ..., buffer: bool = ...) -> None: ...
    def run(self, test: Any) -> Any: ...

def default_test_processes() -> int: ...

class ParallelTestSuite(TestSuite):
    init_worker: Any = ...
    run_subsuite: Any = ...
    runner_class: Any = ...
    subsuites: List[TestSuite] = ...
    processes: int = ...
    failfast: bool = ...
    buffer: bool = ...
    initial_settings: Any = ...
    serialized_contents: Any = ...
    def __init__(
        self, subsuites: List[TestSuite], processes: int, failfast: bool = ..., buffer: bool = ...
    ) -> None: ...
    def run(self, result: Any) -> Any: ...  # type: ignore[override]

class DiscoverRunner:
    test_suite: Type[TestSuite] = ...
    parallel_test_suite: Type[ParallelTestSuite] = ...
    test_runner: Type[TextTestRunner] = ...
    test_loader: TestLoader = ...
    reorder_by: Tuple[SimpleTestCase, ...] = ...
    pattern: Optional[str] = ...
    top_level: Optional[str] = ...
    verbosity: int = ...
    interactive: bool = ...
    failfast: bool = ...
    keepdb: bool = ...
    reverse: bool = ...
    debug_mode: bool = ...
    debug_sql: bool = ...
    parallel: int = ...
    tags: Set[str] = ...
    exclude_tags: Set[str] = ...
    pdb: bool = ...
    buffer: bool = ...
    test_name_patterns: Optional[Set[str]] = ...
    time_keeper: TimeKeeperProtocol = ...
    shuffle: Union[int, Literal[False]] = ...
    logger: Optional[logging.Logger] = ...
    def __init__(
        self,
        pattern: Optional[str] = ...,
        top_level: Optional[str] = ...,
        verbosity: int = ...,
        interactive: bool = ...,
        failfast: bool = ...,
        keepdb: bool = ...,
        reverse: bool = ...,
        debug_mode: bool = ...,
        debug_sql: bool = ...,
        parallel: int = ...,
        tags: Optional[List[str]] = ...,
        exclude_tags: Optional[List[str]] = ...,
        test_name_patterns: Optional[List[str]] = ...,
        pdb: bool = ...,
        buffer: bool = ...,
        enable_faulthandler: bool = ...,
        timing: bool = ...,
        shuffle: Union[int, Literal[False]] = ...,
        logger: Optional[logging.Logger] = ...,
        **kwargs: Any
    ) -> None: ...
    @classmethod
    def add_arguments(cls, parser: ArgumentParser) -> None: ...
    @property
    def shuffle_seed(self) -> Optional[int]: ...
    def log(self, msg: str, level: Optional[int]) -> None: ...
    def setup_test_environment(self, **kwargs: Any) -> None: ...
    def setup_shuffler(self) -> None: ...
    @contextmanager
    def load_with_patterns(self) -> Iterator[None]: ...
    def load_tests_for_label(self, label: str, discover_kwargs: Dict[str, str]) -> TestSuite: ...
    def build_suite(
        self, test_labels: Sequence[str] = ..., extra_tests: Optional[List[Any]] = ..., **kwargs: Any
    ) -> TestSuite: ...
    def setup_databases(self, **kwargs: Any) -> List[Tuple[BaseDatabaseWrapper, str, bool]]: ...
    def get_resultclass(self) -> Optional[Type[TextTestResult]]: ...
    def get_test_runner_kwargs(self) -> Dict[str, Any]: ...
    def run_checks(self, databases: Set[str]) -> None: ...
    def run_suite(self, suite: TestSuite, **kwargs: Any) -> TextTestResult: ...
    def teardown_databases(self, old_config: List[Tuple[BaseDatabaseWrapper, str, bool]], **kwargs: Any) -> None: ...
    def teardown_test_environment(self, **kwargs: Any) -> None: ...
    def suite_result(self, suite: TestSuite, result: TextTestResult, **kwargs: Any) -> int: ...
    def _get_databases(self, suite: TestSuite) -> Set[str]: ...
    def get_databases(self, suite: TestSuite) -> Set[str]: ...
    def run_tests(self, test_labels: List[str], extra_tests: Optional[List[Any]] = ..., **kwargs: Any) -> int: ...

def is_discoverable(label: str) -> bool: ...
def reorder_suite(
    suite: TestSuite, classes: Tuple[Type[TestCase], Type[SimpleTestCase]], reverse: bool = ...
) -> TestSuite: ...
def partition_suite_by_type(
    suite: TestSuite, classes: Tuple[Type[TestCase], Type[SimpleTestCase]], bins: List[OrderedSet], reverse: bool = ...
) -> None: ...
def partition_suite_by_case(suite: Any) -> List[Any]: ...
def filter_tests_by_tags(suite: TestSuite, tags: Set[str], exclude_tags: Set[str]) -> TestSuite: ...
