from collections.abc import Callable, Iterable
from enum import Enum
from typing import Any

from django.db.migrations.graph import MigrationGraph
from django.db.migrations.migration import Migration
from django.db.migrations.operations.base import Operation
from django.db.migrations.questioner import MigrationQuestioner
from django.db.migrations.state import ProjectState
from django.db.models.fields import Field
from django.utils.functional import cached_property
from typing_extensions import Self

class OperationDependency(tuple[str, str, str | None, OperationDependency.Type]):
    class Type(Enum):
        CREATE = 0
        REMOVE = 1
        ALTER = 2
        REMOVE_ORDER_WRT = 3
        ALTER_FOO_TOGETHER = 4
        REMOVE_INDEX_OR_CONSTRAINT = 5

    def __new__(_cls, app_label: str, model_name: str, field_name: str | None, type: Type) -> Self: ...
    app_label: str
    model_name: str
    field_name: str | None
    type: Type
    @cached_property
    def model_name_lower(self) -> str: ...
    @cached_property
    def field_name_lower(self) -> str: ...

class MigrationAutodetector:
    from_state: ProjectState
    to_state: ProjectState
    questioner: MigrationQuestioner
    existing_apps: set[Any]
    def __init__(
        self, from_state: ProjectState, to_state: ProjectState, questioner: MigrationQuestioner | None = None
    ) -> None: ...
    def changes(
        self,
        graph: MigrationGraph,
        trim_to_apps: set[str] | None = None,
        convert_apps: set[str] | None = None,
        migration_name: str | None = None,
    ) -> dict[str, list[Migration]]: ...
    def deep_deconstruct(self, obj: Any) -> Any: ...
    def only_relation_agnostic_fields(
        self, fields: dict[str, Field]
    ) -> list[tuple[str, list[Any], dict[str, Callable | int | str]]]: ...
    def check_dependency(self, operation: Operation, dependency: tuple[str, str, str | None, bool | str]) -> bool: ...
    def add_operation(
        self,
        app_label: str,
        operation: Operation,
        dependencies: Iterable[tuple[str, str, str | None, bool | str]] | None = None,
        beginning: bool = False,
    ) -> None: ...
    def swappable_first_key(self, item: tuple[str, str]) -> tuple[str, str]: ...
    renamed_models: Any
    renamed_models_rel: Any
    def generate_renamed_models(self) -> None: ...
    def generate_created_models(self) -> None: ...
    def generate_created_proxies(self) -> None: ...
    def generate_deleted_models(self) -> None: ...
    def generate_deleted_proxies(self) -> None: ...
    def create_renamed_fields(self) -> None: ...
    renamed_fields: Any
    def generate_renamed_fields(self) -> None: ...
    def generate_added_fields(self) -> None: ...
    def generate_removed_fields(self) -> None: ...
    def generate_altered_fields(self) -> None: ...
    def create_altered_indexes(self) -> None: ...
    def generate_added_indexes(self) -> None: ...
    def generate_removed_indexes(self) -> None: ...
    def generate_renamed_indexes(self) -> None: ...
    def create_altered_constraints(self) -> None: ...
    def generate_added_constraints(self) -> None: ...
    def generate_removed_constraints(self) -> None: ...
    def generate_altered_constraints(self) -> None: ...
    def generate_removed_altered_unique_together(self) -> None: ...
    def generate_altered_unique_together(self) -> None: ...
    def generate_altered_db_table(self) -> None: ...
    def generate_altered_db_table_comment(self) -> None: ...
    def generate_altered_options(self) -> None: ...
    def generate_altered_order_with_respect_to(self) -> None: ...
    def generate_altered_managers(self) -> None: ...
    def arrange_for_graph(
        self, changes: dict[str, list[Migration]], graph: MigrationGraph, migration_name: str | None = None
    ) -> dict[str, list[Migration]]: ...
    @classmethod
    def parse_number(cls, name: str) -> int: ...
