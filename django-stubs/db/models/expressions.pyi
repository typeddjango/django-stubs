from collections import OrderedDict
from datetime import datetime, timedelta
from typing import (Any, Callable, Dict, Iterator, List, Optional, Set, Tuple,
                    Type, Union)

from django.db.models.fields import Field
from django.db.models.lookups import Lookup
from django.db.models.sql.compiler import SQLCompiler


class SQLiteNumericMixin:
    def as_sqlite(
            self,
            compiler: SQLCompiler,
            connection: Any,
            **extra_context: Any
    ) -> Tuple[str, List[float]]: ...


class Combinable:
    ADD: str = ...
    SUB: str = ...
    MUL: str = ...
    DIV: str = ...
    POW: str = ...
    MOD: str = ...
    BITAND: str = ...
    BITOR: str = ...
    BITLEFTSHIFT: str = ...
    BITRIGHTSHIFT: str = ...

    def __neg__(self) -> CombinedExpression: ...

    def __add__(
            self, other: Optional[Union[timedelta, Combinable, float, str]]
    ) -> CombinedExpression: ...

    def __sub__(
            self, other: Union[timedelta, Combinable, float]
    ) -> CombinedExpression: ...

    def __mul__(
            self, other: Union[timedelta, Combinable, float]
    ) -> CombinedExpression: ...

    def __truediv__(self, other: float) -> CombinedExpression: ...

    def __mod__(self, other: int) -> CombinedExpression: ...

    def __pow__(self, other: float) -> CombinedExpression: ...

    def __and__(self, other: Combinable) -> Any: ...

    def bitand(self, other: int) -> CombinedExpression: ...

    def bitleftshift(self, other: int) -> CombinedExpression: ...

    def bitrightshift(self, other: int) -> CombinedExpression: ...

    def __or__(self, other: Combinable) -> Any: ...

    def bitor(self, other: int) -> CombinedExpression: ...

    def __radd__(
            self, other: Optional[Union[datetime, float]]
    ) -> CombinedExpression: ...

    def __rsub__(self, other: float) -> CombinedExpression: ...

    def __rmul__(self, other: float) -> CombinedExpression: ...

    def __rtruediv__(self, other: float) -> CombinedExpression: ...

    def __rmod__(self, other: int) -> CombinedExpression: ...

    def __rpow__(self, other: float) -> CombinedExpression: ...

    def __rand__(self, other: Any) -> Any: ...

    def __ror__(self, other: Any) -> Any: ...


class BaseExpression:
    is_summary: bool = ...
    filterable: bool = ...
    window_compatible: bool = ...

    def __init__(self, output_field: Optional[Union[Field, str]] = ...) -> None: ...

    def get_db_converters(self, connection: Any) -> List[Callable]: ...

    def get_source_expressions(self) -> List[Any]: ...

    def set_source_expressions(self, exprs: List[Any]) -> None: ...

    def as_sql(self, compiler: Any, connection: Any) -> None: ...

    def contains_aggregate(self) -> bool: ...

    def contains_over_clause(self) -> bool: ...

    def contains_column_references(self) -> bool: ...

    def resolve_expression(
            self,
            query: Any = ...,
            allow_joins: bool = ...,
            reuse: Optional[Set[str]] = ...,
            summarize: bool = ...,
            for_save: bool = ...,
    ) -> BaseExpression: ...

    @property
    def field(self) -> Field: ...

    @property
    def output_field(self) -> Field: ...

    def convert_value(self) -> Callable: ...

    def get_lookup(self, lookup: str) -> Optional[Type[Lookup]]: ...

    def get_transform(self, name: str) -> Optional[Type[Expression]]: ...

    def relabeled_clone(
            self, change_map: Union[Dict[Optional[str], str], OrderedDict]
    ) -> Expression: ...

    def copy(self) -> BaseExpression: ...

    def get_group_by_cols(self) -> List[Expression]: ...

    def get_source_fields(self) -> List[Optional[Field]]: ...

    def asc(self, **kwargs: Any) -> Expression: ...

    def desc(self, **kwargs: Any) -> Expression: ...

    def reverse_ordering(self): ...

    def flatten(self) -> Iterator[Expression]: ...

    def __eq__(self, other: object) -> bool: ...

    def __hash__(self) -> int: ...


class Expression(BaseExpression, Combinable): ...


class CombinedExpression(SQLiteNumericMixin, Expression):
    connector: Any = ...
    lhs: Any = ...
    rhs: Any = ...

    def __init__(
            self,
            lhs: Combinable,
            connector: str,
            rhs: Combinable,
            output_field: None = ...,
    ) -> None: ...

    def get_source_expressions(
            self
    ) -> Union[List[Combinable], List[SQLiteNumericMixin]]: ...

    def set_source_expressions(self, exprs: List[Combinable]) -> None: ...

    def as_sql(self, compiler: SQLCompiler, connection: Any) -> Any: ...

    def resolve_expression(
            self,
            query: Any = ...,
            allow_joins: bool = ...,
            reuse: Optional[Set[str]] = ...,
            summarize: bool = ...,
            for_save: bool = ...,
    ) -> CombinedExpression: ...


class F(Combinable):
    def __init__(self, name: str): ...