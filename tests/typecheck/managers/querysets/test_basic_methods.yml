-   case: queryset_basic_methods_return_type
    main: |
        from typing_extensions import reveal_type
        from django.utils import timezone
        from myapp.models import Blog

        qs = Blog.objects.all()
        reveal_type(qs) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.get(id=1)) # N: Revealed type is "myapp.models.Blog"
        reveal_type(iter(qs)) # N: Revealed type is "typing.Iterator[myapp.models.Blog]"
        reveal_type(qs.iterator()) # N: Revealed type is "typing.Iterator[myapp.models.Blog]"
        reveal_type(qs.first()) # N: Revealed type is "myapp.models.Blog | None"
        reveal_type(qs.earliest()) # N: Revealed type is "myapp.models.Blog"
        reveal_type(qs[0]) # N: Revealed type is "myapp.models.Blog"
        reveal_type(qs[:9]) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.create()) # N: Revealed type is "myapp.models.Blog"
        reveal_type(qs.get_or_create()) # N: Revealed type is "tuple[myapp.models.Blog, builtins.bool]"
        reveal_type(qs.exists()) # N: Revealed type is "builtins.bool"
        reveal_type(qs.none()) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.update_or_create()) # N: Revealed type is "tuple[myapp.models.Blog, builtins.bool]"
        reveal_type(qs.explain()) # N: Revealed type is "builtins.str"
        reveal_type(qs.raw(qs.explain())) # N: Revealed type is "django.db.models.query.RawQuerySet[myapp.models.Blog]"
        reveal_type(qs.distinct()) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.distinct("created_at")) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        # .dates / .datetimes
        reveal_type(Blog.objects.dates("created_at", "day")) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, datetime.date]"
        reveal_type(Blog.objects.datetimes("created_at", "day")) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, datetime.datetime]"
        # defer / only
        reveal_type(qs.defer("created_at")) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.defer(None))  # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        reveal_type(qs.only("created_at")) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"
        qs.only(None)  # E: Argument 1 to "only" of "QuerySet" has incompatible type "None"; expected "str"  [arg-type]

        # AND-ing QuerySets
        reveal_type(Blog.objects.all() & Blog.objects.all()) # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.Blog, myapp.models.Blog]"

        # bulk methods
        reveal_type(qs.count()) # N: Revealed type is "builtins.int"
        reveal_type(qs.update(created_at=timezone.now()))  # N: Revealed type is "builtins.int"
        reveal_type(qs.in_bulk()) # N: Revealed type is "builtins.dict[Any, myapp.models.Blog]"
        reveal_type(qs.bulk_update(list(qs), fields=["created_at"]))  # N: Revealed type is "builtins.int"
        reveal_type(qs.bulk_create([]))  # N: Revealed type is "builtins.list[myapp.models.Blog]"
        reveal_type(qs.delete()) # N: Revealed type is "tuple[builtins.int, builtins.dict[builtins.str, builtins.int]]"
    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models

                class Blog(models.Model):
                    created_at = models.DateTimeField()

-   case: queryset_missing_method
    main: |
        from typing_extensions import reveal_type
        from myapp.models import User
        reveal_type(User.objects)  # N: Revealed type is "django.db.models.manager.Manager[myapp.models.User]"
        User.objects.not_existing_method()  # E: "Manager[User]" has no attribute "not_existing_method"  [attr-defined]
    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models
                class User(models.Model):
                    pass

-   case: queryset_method_of_union
    main: |
        from typing_extensions import reveal_type
        from myapp.models import MyModel1, MyModel2
        kls: type[MyModel1 | MyModel2] = MyModel1
        reveal_type(kls.objects)  # N: Revealed type is "django.db.models.manager.Manager[myapp.models.MyModel1] | django.db.models.manager.Manager[myapp.models.MyModel2]"
        reveal_type(kls.objects.all())  # N: Revealed type is "django.db.models.query.QuerySet[myapp.models.MyModel1, myapp.models.MyModel1] | django.db.models.query.QuerySet[myapp.models.MyModel2, myapp.models.MyModel2]"
        reveal_type(kls.objects.get())  # N: Revealed type is "myapp.models.MyModel1 | myapp.models.MyModel2"
    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models
                class MyModel1(models.Model):
                    pass
                class MyModel2(models.Model):
                    pass

-   case: select_related_returns_queryset
    main: |
        from typing_extensions import reveal_type
        from myapp.models import Book
        reveal_type(Book.objects.select_related())
        reveal_type(Book.objects.filter(pk=1).select_related())

        Book.objects.select_related()
        Book.objects.all().select_related()
        Book.objects.select_related(None)
        Book.objects.all().select_related(None)
        Book.objects.select_related("author", "dd") # E: Invalid field name "dd" in select_related lookup. Choices are: author  [misc]
        Book.objects.all().select_related("author", "dd") # E: Invalid field name "dd" in select_related lookup. Choices are: author  [misc]

        Book.objects.select_related("None", None)
        Book.objects.all().select_related("None", None)
        Book.objects.select_related(1)
        Book.objects.all().select_related(1)
        Book.objects.select_related(True)
        Book.objects.all().select_related(True)
    out: |
      main:3: note: Revealed type is "django.db.models.query.QuerySet[myapp.models.Book, myapp.models.Book]"
      main:4: note: Revealed type is "django.db.models.query.QuerySet[myapp.models.Book, myapp.models.Book]"
      main:13: error: No overload variant of "select_related" of "Manager" matches argument types "str", "None"  [call-overload]
      main:13: note: Possible overload variants:
      main:13: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:13: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]
      main:14: error: No overload variant of "select_related" of "QuerySet" matches argument types "str", "None"  [call-overload]
      main:14: note: Possible overload variants:
      main:14: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:14: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]
      main:15: error: No overload variant of "select_related" of "Manager" matches argument type "int"  [call-overload]
      main:15: note: Possible overload variants:
      main:15: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:15: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]
      main:16: error: No overload variant of "select_related" of "QuerySet" matches argument type "int"  [call-overload]
      main:16: note: Possible overload variants:
      main:16: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:16: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]
      main:17: error: No overload variant of "select_related" of "Manager" matches argument type "bool"  [call-overload]
      main:17: note: Possible overload variants:
      main:17: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:17: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]
      main:18: error: No overload variant of "select_related" of "QuerySet" matches argument type "bool"  [call-overload]
      main:18: note: Possible overload variants:
      main:18: note:     def select_related(self, None, /) -> QuerySet[Book, Book]
      main:18: note:     def select_related(self, *fields: str) -> QuerySet[Book, Book]

    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models
                class Person(models.Model):
                    pass

                class Book(models.Model):
                    author = models.ForeignKey(Person, on_delete=models.CASCADE)

-   case: prefetch_related_returns_queryset
    main: |
        from typing_extensions import reveal_type
        from myapp.models import Book
        reveal_type(Book.objects.prefetch_related())
        reveal_type(Book.objects.filter(pk=1).prefetch_related())

        Book.objects.prefetch_related()
        Book.objects.all().prefetch_related()
        Book.objects.prefetch_related(None)
        Book.objects.all().prefetch_related(None)
        Book.objects.prefetch_related("author", "dd") # E: Cannot find "dd" on "Book" object, "dd" is an invalid parameter to "prefetch_related()"  [misc]
        Book.objects.all().prefetch_related("author", "dd") # E: Cannot find "dd" on "Book" object, "dd" is an invalid parameter to "prefetch_related()"  [misc]

        Book.objects.prefetch_related("None", None)
        Book.objects.all().prefetch_related("None", None)
        Book.objects.prefetch_related(1)
        Book.objects.all().prefetch_related(1)
        Book.objects.prefetch_related(True)
        Book.objects.all().prefetch_related(True)
    out: |
      main:3: note: Revealed type is "django.db.models.query.QuerySet[myapp.models.Book, myapp.models.Book]"
      main:4: note: Revealed type is "django.db.models.query.QuerySet[myapp.models.Book, myapp.models.Book]"
      main:13: error: No overload variant of "prefetch_related" of "Manager" matches argument types "str", "None"  [call-overload]
      main:13: note: Possible overload variants:
      main:13: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:13: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]
      main:14: error: No overload variant of "prefetch_related" of "QuerySet" matches argument types "str", "None"  [call-overload]
      main:14: note: Possible overload variants:
      main:14: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:14: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]
      main:15: error: No overload variant of "prefetch_related" of "Manager" matches argument type "int"  [call-overload]
      main:15: note: Possible overload variants:
      main:15: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:15: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]
      main:16: error: No overload variant of "prefetch_related" of "QuerySet" matches argument type "int"  [call-overload]
      main:16: note: Possible overload variants:
      main:16: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:16: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]
      main:17: error: No overload variant of "prefetch_related" of "Manager" matches argument type "bool"  [call-overload]
      main:17: note: Possible overload variants:
      main:17: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:17: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]
      main:18: error: No overload variant of "prefetch_related" of "QuerySet" matches argument type "bool"  [call-overload]
      main:18: note: Possible overload variants:
      main:18: note:     def prefetch_related(self, None, /) -> QuerySet[Book, Book]
      main:18: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> QuerySet[Book, Book]

    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models
                class Person(models.Model):
                    pass

                class Book(models.Model):
                    author = models.ForeignKey(Person, on_delete=models.CASCADE)

-   case: prefetch_related_returns_raw_queryset
    main: |
        from myapp.models import Book
        raw_qs = Book.objects.raw("SELECT 1")
        raw_qs_from_manager = Book.objects.raw("SELECT 1")

        raw_qs_from_manager.prefetch_related()
        raw_qs.prefetch_related()
        raw_qs_from_manager.prefetch_related(None)
        raw_qs.prefetch_related(None)
        raw_qs_from_manager.prefetch_related("author", "dd") # Should be Error on invalid lookup 'dd' !
        raw_qs.prefetch_related("author", "dd") # Should be Error on invalid lookup 'dd' !

        raw_qs_from_manager.prefetch_related("None", None)
        raw_qs.prefetch_related("None", None)
        raw_qs_from_manager.prefetch_related(1)
        raw_qs.prefetch_related(1)
        raw_qs_from_manager.prefetch_related(True)
        raw_qs.prefetch_related(True)
    out: |
      main:12: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument types "str", "None"  [call-overload]
      main:12: note: Possible overload variants:
      main:12: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:12: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]
      main:13: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument types "str", "None"  [call-overload]
      main:13: note: Possible overload variants:
      main:13: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:13: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]
      main:14: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument type "int"  [call-overload]
      main:14: note: Possible overload variants:
      main:14: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:14: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]
      main:15: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument type "int"  [call-overload]
      main:15: note: Possible overload variants:
      main:15: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:15: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]
      main:16: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument type "bool"  [call-overload]
      main:16: note: Possible overload variants:
      main:16: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:16: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]
      main:17: error: No overload variant of "prefetch_related" of "RawQuerySet" matches argument type "bool"  [call-overload]
      main:17: note: Possible overload variants:
      main:17: note:     def prefetch_related(self, None, /) -> RawQuerySet[Book]
      main:17: note:     def [_LookupT: str, _PrefetchedQuerySetT: QuerySet[Model, Model], _ToAttrT: str] prefetch_related(self, *lookups: str | Prefetch[_LookupT, _PrefetchedQuerySetT, _ToAttrT]) -> RawQuerySet[Book]

    installed_apps:
        - myapp
    files:
        -   path: myapp/__init__.py
        -   path: myapp/models.py
            content: |
                from django.db import models
                class Person(models.Model):
                    pass

                class Book(models.Model):
                    author = models.ForeignKey(Person, on_delete=models.CASCADE)
