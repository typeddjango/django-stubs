- case: test_filter_on_abstract_user_pk
  main: |
    from django.contrib.auth.models import AbstractUser
    AbstractUser.objects.get(pk=1)
    AbstractUser.objects.get(pk__in=[1])

    au: AbstractUser
    reveal_type(au.pk)  # N: Revealed type is "Any"
  installed_apps:
    - django.contrib.auth

- case: test_filter_on_abstract_user_pk_wrong_name
  main: |
    from django.contrib.auth.models import AbstractUser
    AbstractUser.objects.get(pkey=1)  # ER: Cannot resolve keyword 'pkey' into field..*
  installed_apps:
    - django.contrib.auth

- case: test_fetch_pk_with_custom_manager_on_abstract_model
  main: |
    from myapp.models import MyModel
  installed_apps:
    - myapp
  files:
    -   path: myapp/__init__.py
    -   path: myapp/models.py
        content: |
            from django.db import models

            class BaseManager(models.Manager):
                pass

            class BaseModel(models.Model):
                objects = BaseManager()

                class Meta:
                    abstract = True

                def lock(self) -> None:
                    reveal_type(type(self).objects.values_list("pk"))  # N: Revealed type is "django.db.models.query._QuerySet[myapp.models.BaseModel, Tuple[Any]]"

            class MyModel(BaseModel):
                field = models.IntegerField()

- case: test_can_instantiate_with_recursive_relation_on_abstract_model
  main: |
    from myapp.models import Concrete, Recursive
    first = Concrete.objects.create(parent=None)
    Concrete.objects.create(parent=first)
    Recursive.objects.create(parent=None)
    Recursive(parent=Recursive(parent=None))
    Concrete(parent=Concrete(parent=None))
  out: |
    main:4: error: "Type[Recursive]" has no attribute "objects"
    main:5: error: Cannot instantiate abstract class "Recursive" with abstract attributes "DoesNotExist" and "MultipleObjectsReturned"
    main:5: error: Unexpected attribute "parent" for model "Recursive"
  installed_apps:
    - myapp
  files:
    -   path: myapp/__init__.py
    -   path: myapp/models.py
        content: |
            from django.db import models

            class Recursive(models.Model):
                parent = models.ForeignKey("self", null=True, on_delete=models.CASCADE)

                class Meta:
                    abstract = True

            class Concrete(Recursive):
                ...


- case: test_abstract_model_type_cannot_be_used_as_runtime_arg
  main: |
      from myapp.models import Abstract, Concrete, LiteralAbstract
      from typing import Generic, Type, TypeVar, overload, Union

      Abstract()  # E: Cannot instantiate abstract class "Abstract" with abstract attributes "DoesNotExist" and "MultipleObjectsReturned"
      LiteralAbstract()  # E: Cannot instantiate abstract class "LiteralAbstract" with abstract attributes "DoesNotExist" and "MultipleObjectsReturned"

      def f(klass: Type[Abstract]) -> None:
          return None

      f(Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      f(Concrete)

      def second_arg(arg: str, klass: Type[Abstract]) -> None:
          return None

      second_arg("abc", Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      second_arg(Abstract, Concrete)  # E: Argument 1 to "second_arg" has incompatible type "Type[Abstract]"; expected "str"

      T = TypeVar("T", bound=Abstract)

      def g(klass: Type[T]) -> None:
          return None

      g(Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      g(Concrete)

      @overload
      def o(klass: Type[T], arg: str) -> None: ...
      @overload
      def o(klass: Type[T], arg: int) -> None: ...
      def o(klass: Type[T], arg: Union[str, int]) -> None:
          return None

      o(Abstract, "a")  # E: Only concrete class can be given where "Type[Abstract]" is expected
      o(Abstract, 1)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      o(Concrete, 1)

      class M:
          def method(self, klass: Type[Abstract]) -> None:
              return None

          @overload
          def overloaded(self, arg: int, klass: Type[Abstract]) -> None:
              ...

          @overload
          def overloaded(self, arg: str, klass: Type[Abstract]) -> None:
              ...

          def overloaded(self, arg: Union[str, int], klass: Type[Abstract]) -> None:
              return None

      M().method(Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      M().overloaded(1, Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      M().overloaded("1", Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected

      class G(Generic[T]):
          def method(self, klass: Type[T]) -> None:
              return None

      G[Abstract]().method(Abstract)  # E: Only concrete class can be given where "Type[Abstract]" is expected
      # Additional plugin coverage
      unknown(Abstract)  # E: Name "unknown" is not defined
      M().unknown(Abstract)  # E: "M" has no attribute "unknown"
  installed_apps:
    - myapp
  files:
    -   path: myapp/__init__.py
    -   path: myapp/models.py
        content: |
            from django.db import models
            from typing import Literal

            class Abstract(models.Model):
                field = models.CharField()

                class Meta:
                    abstract = True

            class Concrete(Abstract):
                ...

            class LiteralAbstract(models.Model):
                class Meta:
                    abstract: Literal[True]


- case: test_use_abstract_model
  main: |
    from myapp.models import create_animal, create_animal_generic, Cat, Animal, ExplicitConcrete
    create_animal(Cat, "Garfield")
    create_animal(Animal, "Animal")  # E: Only concrete class can be given where "Type[Animal]" is expected
    create_animal_generic(Cat, "Grumpy")
    create_animal_generic(Animal, "Animal")  # E: Only concrete class can be given where "Type[Animal]" is expected

    Animal()  # E: Cannot instantiate abstract class "Animal" with abstract attributes "DoesNotExist" and "MultipleObjectsReturned"
    ExplicitConcrete()
  installed_apps:
    - myapp
  files:
    -   path: myapp/__init__.py
    -   path: myapp/models.py
        content: |
            from typing import Protocol, Type, TypeVar
            from django.db import models
            from django_stubs_ext.db.models import TypedModelMeta

            class Animal(models.Model):
                name = models.CharField(max_length=100)

                class Meta(TypedModelMeta):
                    abstract = True

            class Cat(Animal):  # Concrete model
                pass


            class ExplicitConcrete(Animal):
                class Meta:
                    abstract = False

            def f() -> None:
                x: Type[Animal]
                x()
                return None

            def create_animal(klass: Type[Animal], name: str) -> Animal:
                obj = klass(name=name)
                obj.save()
                return obj

            T = TypeVar("T", bound=Animal)

            def create_animal_generic(klass: Type[T], name: str) -> T:
                reveal_type(klass)  # N: Revealed type is "Type[T`-1]"
                return klass._default_manager.create(name=name)
